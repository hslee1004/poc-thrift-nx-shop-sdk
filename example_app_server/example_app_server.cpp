// example_app_server.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <iostream>
#include <vector>

// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.
#include "..\gen-cpp\nxapi_shop.h"

#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PlatformThreadFactory.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TSocket.h>
#include <thrift/transport/TTransportUtils.h>
#include <thrift/TToString.h>

#include <boost/make_shared.hpp>

using namespace std;
using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using boost::shared_ptr;
using namespace  ::nxapi_shop;

//
// if you generate new class, change this part
//
class nxapi_shopHandler : virtual public nxapi_shopIf {
 public:
  nxapi_shopHandler() {
    // Your initialization goes here
  }

  void ping(std::string& _return) {
    // Your implementation goes here
	// test code
    std::time_t t = std::time(0); 
    stringstream ss;
    ss << "[" << t << "]" << " pong" ;
    _return = ss.str();
    printf("ping\n");
  }

  void Initialize(std::string& _return, const std::string& service_code, const int32_t server_no) {
    // Your implementation goes here
    printf("Initialize\n");
  }

  int32_t HeartBeat(const int32_t product_release_ticks) {
    // Your implementation goes here
    printf("HeartBeat\n");
	return 0;
  }

  void CheckBalance(NXAccountBalanceResult& _return, const NXUserId nexon_id) {
    // Your implementation goes here
    printf("CheckBalance\n");
  }

  void CheckBalanceEx(NXAccountBalanceResult& _return, const NXUserId nexon_id, const NXCashType::type cash_type) {
    // Your implementation goes here
    printf("CheckBalanceEx\n");
  }

  void PurchaseItems(NXPurchaseItemsResult& _return, const NXPurchaseItems& items) {
    // Your implementation goes here
    printf("PurchaseItems\n");

	std::cout << "user_ip : " << items.user_ip << std::endl;
	std::cout << "game_id : " << items.gameId << std::endl;
    for (std::vector<NXItem>::const_iterator it = items.items.begin() ; it != items.items.end(); ++it)
    {
      NXItem item = *it;
	  std::cout << "product_no : " << item.product_no << std::endl;
    }
  }

  void InventoryCheck(NXInventoryCheckResult& _return, const NXGameId& game_id, const ENXShowInventory::type show_inventory, const ENXInventoryOrderType::type is_present) {
    // Your implementation goes here
    printf("InventoryCheck\n");
  }

  void InventoryPickup(NXInventoryPickupResult& _return, const NXAPITransactionId order_id, const NXProductNo product_no, const int32_t order_quntity, const std::string& extend_value) {
    // Your implementation goes here
    printf("InventoryPickup\n");
  }

};



class SampleEventHandler : public TServerEventHandler {
protected:
    uint32_t accepted_; //Example member

public:
	SampleEventHandler() : accepted_(0) {}

    //Called before the server begins -
    //virtual void preServe() {}

    //createContext may return a user-defined context to aid in cleaning
    //up client connections upon disconnection. This example dispenses
    //with contextual information and returns NULL.
    virtual void* createContext(boost::shared_ptr<protocol::TProtocol> input, boost::shared_ptr<protocol::TProtocol> output)
    {
        printf("SampleEventHandler callback: Client connected (total %d)\n", ++accepted_);
        return NULL;
    }

    //Called when a client has disconnected, either naturally or by error.
    virtual void deleteContext(void* serverContext, boost::shared_ptr<protocol::TProtocol>input, boost::shared_ptr<protocol::TProtocol>output)
    {
        printf("SampleEventHandler callback: Client disconnected (total %d)\n", --accepted_);
		(void)serverContext;
		(void)input;
		(void)output;
    }

    //Called when a client is about to call the processor -
    //virtual void processContext(void* serverContext,
    boost::shared_ptr<TTransport> transport() {}

};


int _tmain(int argc, _TCHAR* argv[])
{
	try
	{
		TThreadedServer server(
			boost::make_shared<nxapi_shopProcessor>(boost::make_shared<nxapi_shopHandler>()),
			boost::make_shared<TServerSocket>(9090), //port
			boost::make_shared<TBufferedTransportFactory>(),
			boost::make_shared<TBinaryProtocolFactory>());

		boost::shared_ptr<SampleEventHandler> EventHandler(new SampleEventHandler());
		server.setServerEventHandler(EventHandler);

		std::cout << "Starting the server..." << std::endl;
		server.serve();
		std::cout << "Done." << std::endl;
	}
	catch(...)
	{
		std::cout << "exception...." << std::endl;
	}

	return 0;
}
