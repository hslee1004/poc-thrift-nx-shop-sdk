/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef nxapi_shop_TYPES_H
#define nxapi_shop_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace nxapi_shop {

struct NXCashType {
  enum type {
    kNXDefault = 0,
    kNXCredit = 1,
    kNXPrepaid = 2,
    kNXCoupon = 3,
    kNXNexonCash = 13001,
    kNXSera = 13003,
    kNXGamePoint = 9999
  };
};

extern const std::map<int, const char*> _NXCashType_VALUES_TO_NAMES;

struct NXAPIResultsType {
  enum type {
    kNone = 0,
    kSuccess = 1,
    kFail = 2
  };
};

extern const std::map<int, const char*> _NXAPIResultsType_VALUES_TO_NAMES;

struct NXAccountBalanceResultCode {
  enum type {
    kNone = 0,
    kOK = 1,
    kDBError = 99,
    kInServerMaintenance = 255,
    kBlockedUser = 12001,
    kUserNotExist = 12002
  };
};

extern const std::map<int, const char*> _NXAccountBalanceResultCode_VALUES_TO_NAMES;

struct NXPurchaseReason {
  enum type {
    kNXReasonDefault = 0,
    kNXReasonGameClient = 1,
    kNXReasonWeb = 2,
    kNXReasonGameClientInPCCafe = 3,
    kNXReasonWebInPCCafe = 4
  };
};

extern const std::map<int, const char*> _NXPurchaseReason_VALUES_TO_NAMES;

struct NXPaymentRuleId {
  enum type {
    kNXRuleAll = 1,
    kNXRuleAllowRefund = 2,
    kNXRuleNoRefund = 3
  };
};

extern const std::map<int, const char*> _NXPaymentRuleId_VALUES_TO_NAMES;

struct NXPurchaseItemCode {
  enum type {
    kNXRuleAll = 1,
    kNXRuleAllowRefund = 2,
    kNXRuleNoRefund = 3
  };
};

extern const std::map<int, const char*> _NXPurchaseItemCode_VALUES_TO_NAMES;

struct ENXShowInventory {
  enum type {
    kNXShowInvenNone = 0,
    kNXShowInvenDisplayToUser = 10,
    kNXShowInvenHiddenToUser = 30
  };
};

extern const std::map<int, const char*> _ENXShowInventory_VALUES_TO_NAMES;

struct ENXInventoryOrderType {
  enum type {
    kNXInvenOrderTypeNormal = 0,
    kNXInvenOrderTypePresent = 1,
    kNXInvenOrderTypeBoth = 2,
    kNXInvenOrderTypeAll = 3
  };
};

extern const std::map<int, const char*> _ENXInventoryOrderType_VALUES_TO_NAMES;

typedef int64_t NXUserId;

typedef std::string NXGameId;

typedef int32_t NXProductNo;

typedef std::string NXMerchantOrderId;

typedef int32_t NXAPITransactionId;

class NXAPIResult;

class NXCash;

class NXAccountBalance;

class NXAccountBalanceResult;

class NXItem;

class NXPurchaseItems;

class NXPurchaseItemsResult;

class NXInventoryPickupResult;

class NXInventoryCheckResult;

typedef struct _NXAPIResult__isset {
  _NXAPIResult__isset() : response(false), response_value(false) {}
  bool response :1;
  bool response_value :1;
} _NXAPIResult__isset;

class NXAPIResult {
 public:

  NXAPIResult(const NXAPIResult&);
  NXAPIResult& operator=(const NXAPIResult&);
  NXAPIResult() : response((NXAPIResultsType::type)0), response_value() {
  }

  virtual ~NXAPIResult() throw();
  NXAPIResultsType::type response;
  std::string response_value;

  _NXAPIResult__isset __isset;

  void __set_response(const NXAPIResultsType::type val);

  void __set_response_value(const std::string& val);

  bool operator == (const NXAPIResult & rhs) const
  {
    if (!(response == rhs.response))
      return false;
    if (__isset.response_value != rhs.__isset.response_value)
      return false;
    else if (__isset.response_value && !(response_value == rhs.response_value))
      return false;
    return true;
  }
  bool operator != (const NXAPIResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NXAPIResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NXAPIResult &a, NXAPIResult &b);

inline std::ostream& operator<<(std::ostream& out, const NXAPIResult& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NXCash__isset {
  _NXCash__isset() : cash_type(false), cash_amount(false) {}
  bool cash_type :1;
  bool cash_amount :1;
} _NXCash__isset;

class NXCash {
 public:

  NXCash(const NXCash&);
  NXCash& operator=(const NXCash&);
  NXCash() : cash_type((NXCashType::type)0), cash_amount(0) {
  }

  virtual ~NXCash() throw();
  NXCashType::type cash_type;
  int32_t cash_amount;

  _NXCash__isset __isset;

  void __set_cash_type(const NXCashType::type val);

  void __set_cash_amount(const int32_t val);

  bool operator == (const NXCash & rhs) const
  {
    if (!(cash_type == rhs.cash_type))
      return false;
    if (!(cash_amount == rhs.cash_amount))
      return false;
    return true;
  }
  bool operator != (const NXCash &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NXCash & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NXCash &a, NXCash &b);

inline std::ostream& operator<<(std::ostream& out, const NXCash& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NXAccountBalance__isset {
  _NXAccountBalance__isset() : nexon_id(false), balances(false) {}
  bool nexon_id :1;
  bool balances :1;
} _NXAccountBalance__isset;

class NXAccountBalance {
 public:

  NXAccountBalance(const NXAccountBalance&);
  NXAccountBalance& operator=(const NXAccountBalance&);
  NXAccountBalance() : nexon_id(0) {
  }

  virtual ~NXAccountBalance() throw();
  NXUserId nexon_id;
  std::vector<NXCash>  balances;

  _NXAccountBalance__isset __isset;

  void __set_nexon_id(const NXUserId val);

  void __set_balances(const std::vector<NXCash> & val);

  bool operator == (const NXAccountBalance & rhs) const
  {
    if (!(nexon_id == rhs.nexon_id))
      return false;
    if (!(balances == rhs.balances))
      return false;
    return true;
  }
  bool operator != (const NXAccountBalance &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NXAccountBalance & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NXAccountBalance &a, NXAccountBalance &b);

inline std::ostream& operator<<(std::ostream& out, const NXAccountBalance& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NXAccountBalanceResult__isset {
  _NXAccountBalanceResult__isset() : result(false), balance(false) {}
  bool result :1;
  bool balance :1;
} _NXAccountBalanceResult__isset;

class NXAccountBalanceResult {
 public:

  NXAccountBalanceResult(const NXAccountBalanceResult&);
  NXAccountBalanceResult& operator=(const NXAccountBalanceResult&);
  NXAccountBalanceResult() : result((NXAccountBalanceResultCode::type)0) {
  }

  virtual ~NXAccountBalanceResult() throw();
  NXAccountBalanceResultCode::type result;
  NXAccountBalance balance;

  _NXAccountBalanceResult__isset __isset;

  void __set_result(const NXAccountBalanceResultCode::type val);

  void __set_balance(const NXAccountBalance& val);

  bool operator == (const NXAccountBalanceResult & rhs) const
  {
    if (!(result == rhs.result))
      return false;
    if (!(balance == rhs.balance))
      return false;
    return true;
  }
  bool operator != (const NXAccountBalanceResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NXAccountBalanceResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NXAccountBalanceResult &a, NXAccountBalanceResult &b);

inline std::ostream& operator<<(std::ostream& out, const NXAccountBalanceResult& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NXItem__isset {
  _NXItem__isset() : product_no(false), product_price(false), count(false) {}
  bool product_no :1;
  bool product_price :1;
  bool count :1;
} _NXItem__isset;

class NXItem {
 public:

  NXItem(const NXItem&);
  NXItem& operator=(const NXItem&);
  NXItem() : product_no(0), product_price(0), count(0) {
  }

  virtual ~NXItem() throw();
  int32_t product_no;
  int32_t product_price;
  int32_t count;

  _NXItem__isset __isset;

  void __set_product_no(const int32_t val);

  void __set_product_price(const int32_t val);

  void __set_count(const int32_t val);

  bool operator == (const NXItem & rhs) const
  {
    if (!(product_no == rhs.product_no))
      return false;
    if (!(product_price == rhs.product_price))
      return false;
    if (__isset.count != rhs.__isset.count)
      return false;
    else if (__isset.count && !(count == rhs.count))
      return false;
    return true;
  }
  bool operator != (const NXItem &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NXItem & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NXItem &a, NXItem &b);

inline std::ostream& operator<<(std::ostream& out, const NXItem& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NXPurchaseItems__isset {
  _NXPurchaseItems__isset() : user_ip(false), reason(false), gameId(false), nexon_id(false), nexon_oid(false), user_name(false), user_age(false), merchant_order_id(false), payment_type(false), payment_rule_id(false), total_amount(false), items(false) {}
  bool user_ip :1;
  bool reason :1;
  bool gameId :1;
  bool nexon_id :1;
  bool nexon_oid :1;
  bool user_name :1;
  bool user_age :1;
  bool merchant_order_id :1;
  bool payment_type :1;
  bool payment_rule_id :1;
  bool total_amount :1;
  bool items :1;
} _NXPurchaseItems__isset;

class NXPurchaseItems {
 public:

  NXPurchaseItems(const NXPurchaseItems&);
  NXPurchaseItems& operator=(const NXPurchaseItems&);
  NXPurchaseItems() : user_ip(), reason((NXPurchaseReason::type)0), gameId(), nexon_id(0), nexon_oid(0), user_name(), user_age(0), merchant_order_id(), payment_type((NXCashType::type)0), payment_rule_id((NXPaymentRuleId::type)0), total_amount(0) {
  }

  virtual ~NXPurchaseItems() throw();
  std::string user_ip;
  NXPurchaseReason::type reason;
  NXGameId gameId;
  NXUserId nexon_id;
  int32_t nexon_oid;
  std::string user_name;
  int32_t user_age;
  NXMerchantOrderId merchant_order_id;
  NXCashType::type payment_type;
  NXPaymentRuleId::type payment_rule_id;
  int32_t total_amount;
  std::vector<NXItem>  items;

  _NXPurchaseItems__isset __isset;

  void __set_user_ip(const std::string& val);

  void __set_reason(const NXPurchaseReason::type val);

  void __set_gameId(const NXGameId& val);

  void __set_nexon_id(const NXUserId val);

  void __set_nexon_oid(const int32_t val);

  void __set_user_name(const std::string& val);

  void __set_user_age(const int32_t val);

  void __set_merchant_order_id(const NXMerchantOrderId& val);

  void __set_payment_type(const NXCashType::type val);

  void __set_payment_rule_id(const NXPaymentRuleId::type val);

  void __set_total_amount(const int32_t val);

  void __set_items(const std::vector<NXItem> & val);

  bool operator == (const NXPurchaseItems & rhs) const
  {
    if (!(user_ip == rhs.user_ip))
      return false;
    if (!(reason == rhs.reason))
      return false;
    if (!(gameId == rhs.gameId))
      return false;
    if (!(nexon_id == rhs.nexon_id))
      return false;
    if (__isset.nexon_oid != rhs.__isset.nexon_oid)
      return false;
    else if (__isset.nexon_oid && !(nexon_oid == rhs.nexon_oid))
      return false;
    if (__isset.user_name != rhs.__isset.user_name)
      return false;
    else if (__isset.user_name && !(user_name == rhs.user_name))
      return false;
    if (__isset.user_age != rhs.__isset.user_age)
      return false;
    else if (__isset.user_age && !(user_age == rhs.user_age))
      return false;
    if (!(merchant_order_id == rhs.merchant_order_id))
      return false;
    if (!(payment_type == rhs.payment_type))
      return false;
    if (!(payment_rule_id == rhs.payment_rule_id))
      return false;
    if (!(total_amount == rhs.total_amount))
      return false;
    if (!(items == rhs.items))
      return false;
    return true;
  }
  bool operator != (const NXPurchaseItems &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NXPurchaseItems & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NXPurchaseItems &a, NXPurchaseItems &b);

inline std::ostream& operator<<(std::ostream& out, const NXPurchaseItems& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NXPurchaseItemsResult__isset {
  _NXPurchaseItemsResult__isset() : merchant_order_id(false), transaction_id(false), payment_rule_id(false), total_amount(false), items(false), extend_value(false) {}
  bool merchant_order_id :1;
  bool transaction_id :1;
  bool payment_rule_id :1;
  bool total_amount :1;
  bool items :1;
  bool extend_value :1;
} _NXPurchaseItemsResult__isset;

class NXPurchaseItemsResult {
 public:

  NXPurchaseItemsResult(const NXPurchaseItemsResult&);
  NXPurchaseItemsResult& operator=(const NXPurchaseItemsResult&);
  NXPurchaseItemsResult() : merchant_order_id(), transaction_id(0), payment_rule_id((NXPaymentRuleId::type)0), total_amount(0), extend_value() {
  }

  virtual ~NXPurchaseItemsResult() throw();
  NXMerchantOrderId merchant_order_id;
  NXAPITransactionId transaction_id;
  NXPaymentRuleId::type payment_rule_id;
  int32_t total_amount;
  std::vector<NXItem>  items;
  std::string extend_value;

  _NXPurchaseItemsResult__isset __isset;

  void __set_merchant_order_id(const NXMerchantOrderId& val);

  void __set_transaction_id(const NXAPITransactionId val);

  void __set_payment_rule_id(const NXPaymentRuleId::type val);

  void __set_total_amount(const int32_t val);

  void __set_items(const std::vector<NXItem> & val);

  void __set_extend_value(const std::string& val);

  bool operator == (const NXPurchaseItemsResult & rhs) const
  {
    if (!(merchant_order_id == rhs.merchant_order_id))
      return false;
    if (!(transaction_id == rhs.transaction_id))
      return false;
    if (!(payment_rule_id == rhs.payment_rule_id))
      return false;
    if (!(total_amount == rhs.total_amount))
      return false;
    if (!(items == rhs.items))
      return false;
    if (!(extend_value == rhs.extend_value))
      return false;
    return true;
  }
  bool operator != (const NXPurchaseItemsResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NXPurchaseItemsResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NXPurchaseItemsResult &a, NXPurchaseItemsResult &b);

inline std::ostream& operator<<(std::ostream& out, const NXPurchaseItemsResult& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NXInventoryPickupResult__isset {
  _NXInventoryPickupResult__isset() : result(false), order_no(false), product_no(false), order_quantity(false), extend_value(false) {}
  bool result :1;
  bool order_no :1;
  bool product_no :1;
  bool order_quantity :1;
  bool extend_value :1;
} _NXInventoryPickupResult__isset;

class NXInventoryPickupResult {
 public:

  NXInventoryPickupResult(const NXInventoryPickupResult&);
  NXInventoryPickupResult& operator=(const NXInventoryPickupResult&);
  NXInventoryPickupResult() : result(0), order_no(0), product_no(0), order_quantity(0), extend_value() {
  }

  virtual ~NXInventoryPickupResult() throw();
  int32_t result;
  NXAPITransactionId order_no;
  NXProductNo product_no;
  int32_t order_quantity;
  std::string extend_value;

  _NXInventoryPickupResult__isset __isset;

  void __set_result(const int32_t val);

  void __set_order_no(const NXAPITransactionId val);

  void __set_product_no(const NXProductNo val);

  void __set_order_quantity(const int32_t val);

  void __set_extend_value(const std::string& val);

  bool operator == (const NXInventoryPickupResult & rhs) const
  {
    if (!(result == rhs.result))
      return false;
    if (!(order_no == rhs.order_no))
      return false;
    if (!(product_no == rhs.product_no))
      return false;
    if (!(order_quantity == rhs.order_quantity))
      return false;
    if (!(extend_value == rhs.extend_value))
      return false;
    return true;
  }
  bool operator != (const NXInventoryPickupResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NXInventoryPickupResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NXInventoryPickupResult &a, NXInventoryPickupResult &b);

inline std::ostream& operator<<(std::ostream& out, const NXInventoryPickupResult& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NXInventoryCheckResult__isset {
  _NXInventoryCheckResult__isset() : result(false), order_type(false), total_count(false) {}
  bool result :1;
  bool order_type :1;
  bool total_count :1;
} _NXInventoryCheckResult__isset;

class NXInventoryCheckResult {
 public:

  NXInventoryCheckResult(const NXInventoryCheckResult&);
  NXInventoryCheckResult& operator=(const NXInventoryCheckResult&);
  NXInventoryCheckResult() : result(0), order_type((ENXInventoryOrderType::type)0), total_count(0) {
  }

  virtual ~NXInventoryCheckResult() throw();
  int32_t result;
  ENXInventoryOrderType::type order_type;
  int32_t total_count;

  _NXInventoryCheckResult__isset __isset;

  void __set_result(const int32_t val);

  void __set_order_type(const ENXInventoryOrderType::type val);

  void __set_total_count(const int32_t val);

  bool operator == (const NXInventoryCheckResult & rhs) const
  {
    if (!(result == rhs.result))
      return false;
    if (!(order_type == rhs.order_type))
      return false;
    if (!(total_count == rhs.total_count))
      return false;
    return true;
  }
  bool operator != (const NXInventoryCheckResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NXInventoryCheckResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NXInventoryCheckResult &a, NXInventoryCheckResult &b);

inline std::ostream& operator<<(std::ostream& out, const NXInventoryCheckResult& obj)
{
  obj.printTo(out);
  return out;
}

} // namespace

#endif
